<!DOCTYPE html>
<html>

<head>
    <title>Making a small tool to jump multiple directory levels quickly</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../style/post.css">
    <link
        href="https://fonts.googleapis.com/css2?family=Merriweather:ital,wght@0,300;0,400;0,700;0,900;1,300;1,400;1,700;1,900&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
</head>

<body>
    <div class="toplevel">
        <div class="main-container">
            <div class="card">
                <a class="back-button" href="../index.html">
                    <img src="../images/back.png" width="20px" height="20px">back
                </a>

                <div class="content">

                    <h1><a href="https://github.com/tedbauer/homebrew-up"><code>up</code></a>: jump multiple directory levels quickly</h1>
<h2>Introduction</h2>
<p>Recently in my day to day, I have been <code>cd</code>ing around deeply nested directories, and I have been finding myself often typing <code>cd ..</code> repeatedly. I often find myself wishing I can just quickly jump up a few directory levels from the current working directory in a quick and natural way. I was also curious to learn about how tab autocomplete is implemented in the shell, so I was inspired to make a tool to enable this.</p>
<p>Here is a short demo of <code>up</code> in action:</p>
<p><a href="https://asciinema.org/a/fdSxD29IhP6LmXuGQpbm27sNf"><img src="https://asciinema.org/a/fdSxD29IhP6LmXuGQpbm27sNf.svg" alt="asciicast" /></a></p>
<p>You can type <code>up d</code>, where <code>d</code> is either a directory above you, or a prefix of a directory above you, and you will be <code>cd</code>'d up to that directory.</p>
<h2>Implementing autocomplete for bash</h2>
<p>Bash provides a mechanism for user-created autocompletion with the <a href="https://linuxcommand.org/lc3_man_pages/completeh.html"><code>complete</code></a> command. You pass it the name of the command you want to support autocomplete for, and then the name of a function that dynamically generates the set of possible autocompletes, based on the current user input:</p>
<pre><code>up_completion() {
    completions=$($BINARY_PATH --complete $COMP_CWORD $COMP_LINE)
    COMPREPLY=($completions)
}

complete -F up_completion up
</code></pre>
<p>Here, we get the user input from <code>$COMP_CWORD</code> (an index into a space-separated list of input words) and <code>$COMP_LINE</code> (the entire user input line) and pass them to a Rust binary that computes the possible autocompletes. Setting <code>$COMPREPLY</code> supplies the autocomplete options to the user.</p>
<p>In the Rust binary, we get the current working directory, determine each directory name, and then return a list of directory names that contain the input as a prefix:</p>
<pre><code>fn generate_completion_options(working_dir: &amp;str, comp_line: &amp;str, comp_cword: usize) -&gt; Vec&lt;String&gt; {
    // If there is already a whole argument, don't suggest more autocompletes.
    if comp_cword &gt; 1 {
        return vec![];
    }

    let directories = working_dir
        .split('/')
        .map(|s| String::from(s))
        .collect::&lt;Vec&lt;String&gt;&gt;();

    let user_input = match comp_line.split(" ").nth(1) {
        Some(arg) =&gt; arg,

        // If there is no input yet, list all directories.
        None =&gt; return directories,
    };

    let mut result = Vec::new();
    for (_, directory) in directories.iter().enumerate() {
        if directory.starts_with(user_input) {
            result.push(directory.to_string());
        }
    }

    if result.is_empty() {
        directories
    } else {
        result
    }
}
</code></pre>
<h2>Other similar things</h2>
<p>There are lots of other useful and creative tools for navigating directories quickly:</p>
<ul>
<li>fuzzy finders, like <a href="https://github.com/junegunn/fzf"><code>fzf</code></a></li>
<li><a href="https://github.com/rupa/z"><code>z</code></a></li>
<li><a href="https://linux.die.net/man/1/cdargs"><code>cdargs</code></a>, <a href="https://linuxcommand.org/lc3_man_pages/pushdh.html"><code>pushd</code></a> / <a href="https://linuxcommand.org/lc3_man_pages/popdh.html"><code>popd</code></a></li>
</ul>
<p>In the Android repository, there is an <a href="https://cs.android.com/android/platform/superproject/main/+/main:build/make/envsetup.sh">environment setup script</a> that sets up an alias, <a href="https://cs.android.com/android/_/android/platform/build/+/db666bcb0ce5934f75664076306a5912c0aa89b7:envsetup.sh;l=1044;bpv=1;bpt=0"><code>croot</code></a>, that <code>cd</code>'s you to the root of the project.</p>
<h2>Try it out</h2>
<p>Try it out by installing it with Homebrew:</p>
<pre><code>brew tap tedbauer/homebrew-up
brew install tedbauer/homebrew-up/up
</code></pre>
<p>Alternatively, you can install it manually. You can clone the repo:</p>
<pre><code>git clone https://github.com/tedbauer/homebrew-up
</code></pre>
<p>The installation comprises of two main things:</p>
<ul>
<li><code>up-path-gen</code>: a Rust binary that computes the paths.</li>
<li><code>up.sh</code>: contains a function <code>up</code>, which is what the user ends up invoking. It invokes <code>up-path-gen</code>.</li>
</ul>
<p>You can build the binary, and install it somewhere like <code>/usr/lib</code>, and similarly install <code>up.sh</code> as well:</p>
<pre><code>cd Formula/up-path-gen &amp;&amp; cargo build --release
cp target/release/up-path-gen /usr/lib
cd ..
cp up.sh /usr/lib
</code></pre>
<p>Then, source <code>up.sh</code> in your shell configuration:</p>
<pre><code>export BINARY_PATH="/usr/lib/up-path-gen"
source /usr/lib/up.sh
</code></pre>


                </div>
                
                <div class="post-footer">
                    <button id="backToTopBtn" class="back-to-top">
                        <img src="../images/up.png" width="26px" height="26px">back to top
                    </button>
                    <a href="https://github.com/tedbauer/tedbauer.github.io/edit/master/pages&#x2F;posts&#x2F;notes1.md" class="typo-button">
                        <img src="../images/pencil.png" width="26px" height="26px">fix a typo
                    </a>
                </div>
            </div>
        </div>
        <div id="postNavbar"></div>
    </div>
    <script>

        hljs.highlightAll();
        const postNavbar = document.getElementById('postNavbar');
        const headers = document.querySelectorAll('h2, h3, h4, h5, h6');
        const backToTopBtn = document.getElementById('backToTopBtn');

        // Back to top button functionality
        backToTopBtn.addEventListener('click', () => {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Create list elements for each header
        headers.forEach(header => {
            const listItem = document.createElement('li');

            // Special handling for h3 elements
            if (header.tagName.toLowerCase() === 'h3') {
                listItem.textContent = header.textContent;
                listItem.classList.add('h3-item');
            } else {
                listItem.textContent = header.textContent;
            }

            listItem.addEventListener('click', (e) => {
                // Immediately set this header as active when clicked
                header.scrollIntoView();
                setActiveHeader(header);
                e.preventDefault();
            });
            postNavbar.appendChild(listItem);
        });

        function setActiveHeader(header) {
            const allItems = postNavbar.querySelectorAll('li');
            allItems.forEach(item => item.classList.remove('active'));

            const index = Array.from(headers).indexOf(header);
            if (index !== -1) {
                allItems[index].classList.add('active');
            }
        }

        function findVisibleHeader() {
            // If we're near the bottom of the page, return the last header
            if (window.innerHeight + window.scrollY >= document.documentElement.scrollHeight - 50) {
                return headers[headers.length - 1];
            }

            // Check for headers near the top of the viewport (within 100px)
            const topThreshold = 100;
            let closestHeader = null;
            let closestDistance = Infinity;

            headers.forEach(header => {
                const rect = header.getBoundingClientRect();
                // Consider both headers slightly above and below the top
                const distance = Math.abs(rect.top);
                if (distance < closestDistance && rect.top > -topThreshold) {
                    closestDistance = distance;
                    closestHeader = header;
                }
            });

            // If we found a header near the top, return it
            if (closestHeader) {
                return closestHeader;
            }

            // If no header is near the top, find the last header that's above the viewport
            let lastHeaderAbove = null;
            headers.forEach(header => {
                const rect = header.getBoundingClientRect();
                if (rect.bottom <= 0) {
                    lastHeaderAbove = header;
                }
            });

            return lastHeaderAbove || headers[0];
        }

        function onScroll() {
            const visibleHeader = findVisibleHeader();
            if (visibleHeader) {
                setActiveHeader(visibleHeader);
            }
        }

        // Initial call to update active state
        onScroll();

        // Add debounced scroll listener
        let scrollTimeout;
        window.addEventListener('scroll', () => {
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(onScroll, 10);
        }, { passive: true });
    </script>
</body>

</html>
